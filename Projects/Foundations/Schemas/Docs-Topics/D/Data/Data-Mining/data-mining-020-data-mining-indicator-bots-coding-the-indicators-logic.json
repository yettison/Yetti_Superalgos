{
    "topic": "Data Mining",
    "pageNumber": 20,
    "type": "Data Mining - Indicator Bots - Coding the Indicator's Logic",
    "definition": {
        "text": "Learn how to use data dependencies, the variable object, and how to deal with indicators with irregular periods.",
        "updated": 1611429211176,
        "translations": [
            {
                "language": "DE",
                "text": "Lernen Sie, wie man data dependencies und das variable object verwendet und wie man mit indicators mit unregelmäßigen Perioden (irregular periods) umgeht.",
                "updated": 1635354439837
            },
            {
                "language": "RU",
                "text": "Узнайте, как использовать зависимости данных, переменный объект и как работать с индикаторами с нерегулярными периодами.",
                "updated": 1639670541463
            },
            {
                "language": "TR",
                "text": "Özet: Veri bağımlılıklarını, değişken nesneyi nasıl kullanacağınızı ve düzensiz dönemli göstergelerle nasıl başa çıkacağınızı öğrenin.",
                "updated": 1645972689835
            }
        ]
    },
    "paragraphs": [
        {
            "style": "Title",
            "text": "Main Data Dependency",
            "updated": 1611430812568,
            "translations": [
                {
                    "language": "DE",
                    "text": "Haupt-Data Dependency:",
                    "updated": 1635354651687
                },
                {
                    "language": "RU",
                    "text": "Основная зависимость от данных (Main Data Dependency)",
                    "updated": 1639676429660
                },
                {
                    "language": "TR",
                    "text": "Ana Veri Bağımlılığı",
                    "updated": 1645972834093
                }
            ]
        },
        {
            "style": "Text",
            "text": "The data building procedure works under the premise that the algorithm loops around a data collection and that—for each loop—generates a record for the product being built. For example, the SMA indicator loops around the candles product of the Candles Volumes indicator, thus, candles is the main data dependency. In the case of the bollingerChannels product, the main data dependency is the bollingerBands product of the Bollinger Bands indicator.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Die data building procedure funktioniert unter der Prämisse, dass der Algorithmus in Schleifen um eine Datensammlung herumläuft und für jede Schleife einen Datensatz für das zu erstellende Produkt erzeugt. Der SMA-Indikator umkreist beispielsweise das Kerzen-Produkt des Kerzen-Volumen-Indikators, so dass die Kerzen die main Datenabhängigkeit darstellen. Im Fall des Produkts bollingerChannels ist die Hauptdatenabhängigkeit das Produkt bollingerBands des Indikators Bollinger Bands.",
                    "updated": 1635354770094
                },
                {
                    "language": "RU",
                    "text": "Процедура построения данных работает на основе того, что алгоритм циклически обращается к сбору данных и для каждого цикла генерирует запись для строящегося продукта. Например, индикатор SMA циклично взаимодействует с продуктом Candles индикатора Candles Volumes, таким образом, свечи являются основной зависимостью данных. В случае продукта bollingerChannels основной зависимостью данных является продукт bollingerBands индикатора Bollinger Bands.",
                    "updated": 1639722475226
                },
                {
                    "language": "TR",
                    "text": "Veri oluşturma prosedürü, algoritmanın bir veri toplama etrafında döndüğü ve her döngü için oluşturulmakta olan ürün için bir kayıt oluşturduğu öncülü altında çalışır. Örneğin, SMA göstergesi Mum Hacimleri göstergesinin mum ürününün etrafında döner, bu nedenle mumlar ana veri bağımlılığıdır. BollingerChannels ürünü söz konusu olduğunda, ana veri bağımlılığı Bollinger Bantları göstergesinin bollingerBands ürünüdür.",
                    "updated": 1645972727275
                }
            ]
        },
        {
            "style": "Text",
            "text": "The main data dependency is the first dependency declared at the level of the processes. This dependency is made available in the record object, which features three properties:",
            "translations": [
                {
                    "language": "DE",
                    "text": "Die main data dependency ist die erste Abhängigkeit, die auf der Ebene der Prozesse deklariert wird. Diese Abhängigkeit wird im record object zur Verfügung gestellt, das über drei Eigenschaften verfügt:",
                    "updated": 1635354968813
                },
                {
                    "language": "RU",
                    "text": "Основная зависимость данных - это первая зависимость, объявленная на уровне процессов. Эта зависимость доступна в объекте записи, который имеет три свойства:",
                    "updated": 1639676238380
                },
                {
                    "language": "TR",
                    "text": "Ana veri bağımlılığı, süreçler düzeyinde bildirilen ilk bağımlılıktır. Bu bağımlılık, üç özelliği içeren kayıt nesnesinde kullanıma sunulur:",
                    "updated": 1645972738656
                }
            ]
        },
        {
            "style": "List",
            "text": "previous: ",
            "updated": 1611429276716,
            "translations": [
                {
                    "language": "TR",
                    "text": "önceki:",
                    "updated": 1645972777374
                }
            ]
        },
        {
            "style": "Javascript",
            "text": "mainDependency.records[index - 1]"
        },
        {
            "style": "List",
            "text": "current: ",
            "updated": 1611429281291,
            "translations": [
                {
                    "language": "TR",
                    "text": "şimdiki:",
                    "updated": 1645972785742
                }
            ]
        },
        {
            "style": "Javascript",
            "text": "mainDependency.records[index]",
            "updated": 1611429297570
        },
        {
            "style": "List",
            "text": "next: ",
            "updated": 1611429287433,
            "translations": [
                {
                    "language": "TR",
                    "text": "sonraki:",
                    "updated": 1645972793769
                }
            ]
        },
        {
            "style": "Javascript",
            "text": "mainDependency.records[index + 1]"
        },
        {
            "style": "Text",
            "text": "The variable index is the index in the array of the main dependency.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Die Variable index ist der Index im Array der main dependency.",
                    "updated": 1635355002222
                },
                {
                    "language": "RU",
                    "text": "Переменная index - это индекс в массиве основной зависимости.",
                    "updated": 1639676297703
                },
                {
                    "language": "TR",
                    "text": "Değişken indeksi, ana bağımlılığın dizisindeki indekstir.",
                    "updated": 1645972825284
                }
            ]
        },
        {
            "style": "Text",
            "text": "For example, you may use the statement record.propertyName to access the value of any of the properties in the input datasets for the current record, or record.previous.propertyName to access the value of the property in the previous record.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Sie können zum Beispiel die Anweisung record.propertyName verwenden, um auf den Wert einer beliebigen Eigenschaft in den Eingabedatensätzen für den aktuellen Datensatz zuzugreifen, oder record.previous.propertyName, um auf den Wert der Eigenschaft im vorherigen Datensatz zuzugreifen.",
                    "updated": 1635355095733
                },
                {
                    "language": "RU",
                    "text": "Например, вы можете использовать оператор record.propertyName для доступа к значению любого из свойств во входных наборах данных для текущей записи или record.previous.propertyName для доступа к значению свойства в предыдущей записи.",
                    "updated": 1639676324151
                },
                {
                    "language": "TR",
                    "text": "Örneğin, geçerli kayıt için girdi veri kümelerindeki herhangi bir özelliğin değerine erişmek için record.propertyName ifadesini veya önceki kayıttaki özelliğin değerine erişmek için record.previous.propertyName ifadesini kullanabilirsiniz.",
                    "updated": 1645972844115
                }
            ]
        },
        {
            "style": "Note",
            "text": "The order in which dependencies are defined determines which one is the main data dependency.",
            "updated": 1611429327162,
            "translations": [
                {
                    "language": "DE",
                    "text": "Die Reihenfolge, in der die dependencies definiert werden, bestimmt, welche die Hauptdatenabhängigkeit ist.",
                    "updated": 1635355151609
                },
                {
                    "language": "RU",
                    "text": "Порядок определения зависимостей определяет, какая из них является основной зависимостью данных.",
                    "updated": 1639676339363
                },
                {
                    "language": "TR",
                    "text": "Not: Bağımlılıkların tanımlanma sırası, hangisinin ana veri bağımlılığı olduğunu belirler.",
                    "updated": 1645972856031
                }
            ]
        },
        {
            "style": "Title",
            "text": "Multiple Data Dependencies",
            "updated": 1611430826204,
            "translations": [
                {
                    "language": "DE",
                    "text": "Mehrere Data Dependencies:",
                    "updated": 1635355230718
                },
                {
                    "language": "RU",
                    "text": "Множественные зависимости от данных (Multiple Data Dependencies)",
                    "updated": 1639676408965
                },
                {
                    "language": "TR",
                    "text": "Çoklu Veri Bağımlılığı",
                    "updated": 1645972888951
                }
            ]
        },
        {
            "style": "Text",
            "text": "The products object features a property for each data dependency, and each property is named with the pluralVariableName defined in the product’s configuration. Each property features an array with the dependency’s data collection.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Das products-Objekt enthält eine Eigenschaft für jede Datenabhängigkeit, und jede Eigenschaft ist mit dem in der Produktkonfiguration definierten pluralVariableName benannt. Jede Eigenschaft enthält ein Array mit der Datensammlung der Abhängigkeit.",
                    "updated": 1635355293053
                },
                {
                    "language": "RU",
                    "text": "Объект products имеет свойство для каждой зависимости данных, и каждое свойство имеет pluralVariableName, определенное в конфигурации продукта. Каждое свойство представляет собой массив с набором данных зависимости.",
                    "updated": 1639676565091
                },
                {
                    "language": "TR",
                    "text": "Ürünler nesnesi, her veri bağımlılığı için bir özellik içerir ve her özellik, ürünün yapılandırmasında tanımlanan pluralVariableName ile adlandırılır. Her özellik, bağımlılığın veri toplamasına sahip bir diziye sahiptir.",
                    "updated": 1645972910805
                }
            ]
        },
        {
            "style": "Text",
            "text": "Data collections of different products may begin and end at different points in time. For example, it takes 20 candles to build the first bollingerBands object of the Bollinger Bands indicator, or 200 candles to build the first popularSMAs object of the SMA indicator. Therefore, the record in i position in the array of one product may not correspond to the same period of time of the record in the same position of a different product.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Data collections für verschiedene Produkte können zu unterschiedlichen Zeitpunkten beginnen und enden. So dauert es beispielsweise 20 Kerzen, um das erste bollingerBands-Objekt des Bollinger Bands-Indikators zu erstellen, oder 200 Kerzen, um das erste popularSMAs-Objekt des SMA-Indikators zu erstellen. Daher entspricht der Datensatz an der Position \"i\" im Array eines Produkts möglicherweise nicht demselben Zeitraum wie der Datensatz an derselben Position eines anderen Produkts.",
                    "updated": 1635355398375
                },
                {
                    "language": "RU",
                    "text": "Сбор данных по разным продуктам может начинаться и заканчиваться в разные моменты времени. Например, требуется 20 свечей, чтобы построить первый объект bollingerBands индикатора Bollinger Bands, или 200 свечей, чтобы построить первые popularSMA индикатора SMA. Следовательно, запись в позиции i в массиве одного продукта может не соответствовать тому же периоду времени записи в той же позиции другого продукта.",
                    "updated": 1639676703769
                },
                {
                    "language": "TR",
                    "text": "Farklı ürünlerin veri toplamaları, zaman içinde farklı noktalarda başlayıp bitebilir. Örneğin, Bollinger Bantları göstergesinin ilk bollingerBands nesnesini oluşturmak için 20 mum veya SMA göstergesinin ilk popülerSMA nesnesini oluşturmak için 200 mum gerekir. Bu nedenle, bir ürünün dizisindeki i konumundaki kayıt, farklı bir ürünün aynı konumundaki kaydın aynı zaman periyoduna karşılık gelmeyebilir.",
                    "updated": 1645972936173
                }
            ]
        },
        {
            "style": "Subtitle",
            "text": "getElement Function",
            "translations": [
                {
                    "language": "DE",
                    "text": "\"getElement Function\" ",
                    "updated": 1635355493612
                },
                {
                    "language": "RU",
                    "text": "Функция getElement",
                    "updated": 1639676720490
                },
                {
                    "language": "TR",
                    "text": "getElement İşlevi",
                    "updated": 1645972949338
                }
            ]
        },
        {
            "style": "Text",
            "text": "This function allows users to locate an object at a dataset whose objects does not have a begin and end property but instead, they have a timestamp property. It receives an arbitrary begin / end object and the function will search within the dependency dataset for the first record whose timestamp is within the begin and end of the received reference objet. For example, a user can get the News record that belong to a certain Candle object.",
            "updated": 1621105823745,
            "translations": [
                {
                    "language": "DE",
                    "text": "Diese Funktion ermöglicht es dem Benutzer, ein Objekt in einem Datensatz zu finden, dessen Objekte keine Anfangs- und Ende-Eigenschaft haben, sondern eine timestamp (Zeitstempel) Eigenschaft besitzen. Sie empfängt ein beliebiges Anfangs-/Endobjekt, und die Funktion sucht innerhalb des Abhängigkeitsdatensatzes nach dem ersten Datensatz, dessen Zeitstempel mit dem Anfang und Ende des empfangenen Referenzobjekts übereinstimmt. Zum Beispiel kann ein Benutzer die News-Datensätze abrufen, die zu einem bestimmten Candle object gehören.",
                    "updated": 1635355600885
                },
                {
                    "language": "RU",
                    "text": "Эта функция позволяет пользователям находить объект в наборе данных, у объектов которого нет свойства begin и end, но вместо этого у них есть свойство timestamp. Он получает произвольный объект начала / конца, и функция будет искать в наборе данных зависимостей первую запись, метка времени которой совпадает с началом и концом полученного ссылочного объекта. Например, пользователь может получить запись новостей, принадлежащую определенному объекту Candle.",
                    "updated": 1639676797678
                },
                {
                    "language": "TR",
                    "text": "Bu işlev, kullanıcıların bir veri kümesindeki nesneleri bir başlangıç ve bitiş özelliği olmayan, bunun yerine bir zaman damgası özelliğine sahip olan bir nesneyi bulmasını sağlar. Rastgele bir başlangıç / bitiş nesnesi alır ve işlev, zaman damgası alınan referans nesnesinin başlangıç ve bitişinde olan ilk kayıt için bağımlılık veri kümesi içinde arama yapar. Örneğin, bir kullanıcı belirli bir Candle nesnesine ait Haber kaydını alabilir.",
                    "updated": 1645972962710
                }
            ]
        },
        {
            "style": "Text",
            "text": "The getElement function, which takes two parameters, may be used:",
            "updated": 1621105837484,
            "translations": [
                {
                    "language": "DE",
                    "text": "Die Funktion getElement, die zwei Parameter benötigt, kann so verwendet werden:",
                    "updated": 1635355644238
                },
                {
                    "language": "RU",
                    "text": "Можно использовать функцию getElement, которая принимает два параметра:",
                    "updated": 1639676874313
                },
                {
                    "language": "TR",
                    "text": "İki parametre alan getElement işlevi kullanılabilir:",
                    "updated": 1645973041195
                }
            ]
        },
        {
            "style": "List",
            "text": "The name of the data collection (pluralVariableName) you wish to consult.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Der Name der Datensammlung (pluralVariableName) die Sie abfragen möchten.",
                    "updated": 1635355679335
                },
                {
                    "language": "RU",
                    "text": "Имя набора данных (pluralVariableName), к которому вы хотите обратиться.",
                    "updated": 1639676889008
                },
                {
                    "language": "TR",
                    "text": "Danışmak istediğiniz veri toplamanın (pluralVariableName) adı.",
                    "updated": 1645973076570
                }
            ]
        },
        {
            "style": "List",
            "text": "An object with begin and end properties, for example, the tenth candle.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Ein Objekt mit Anfangs- und Endeigenschaften, zum Beispiel die zehnte candle.",
                    "updated": 1635355699147
                },
                {
                    "language": "RU",
                    "text": "Объект со свойствами begin и end, например десятая свеча.",
                    "updated": 1639676945239
                },
                {
                    "language": "TR",
                    "text": "Başlangıç ve bitiş özelliklerine sahip bir nesne, örneğin onuncu mum.",
                    "updated": 1645973089517
                }
            ]
        },
        {
            "style": "Text",
            "text": "The function returns the record that matches the begin and end datetime of the second parameter.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Die Funktion gibt den Datensatz zurück, der mit dem Anfangs- und Enddatum des zweiten Parameters übereinstimmt.",
                    "updated": 1635355840137
                },
                {
                    "language": "RU",
                    "text": "Функция возвращает запись, которая соответствует датам начала и окончания второго параметра.",
                    "updated": 1639677433185
                },
                {
                    "language": "TR",
                    "text": "İşlev, ikinci parametrenin başlangıç ve bitiş tarih saatiyle eşleşen kaydı döndürür.",
                    "updated": 1645973100900
                }
            ]
        },
        {
            "style": "Text",
            "text": "This is an example from the Candle Patterns indicator, which has the candles product of the Candles Volumes indicator as the main data dependency:",
            "translations": [
                {
                    "language": "DE",
                    "text": "Dies ist ein Beispiel aus dem Candle Patterns indicator, der das candle product des Candles Volumes indicator als Hauptdatenabhängigkeit hat:",
                    "updated": 1635355927938
                },
                {
                    "language": "RU",
                    "text": "Это пример индикатора Candle Patterns, в котором прдукт Candles индикатора Candles Volumes является основной зависимостью данных:",
                    "updated": 1639722462769
                },
                {
                    "language": "TR",
                    "text": "Bu, ana veri bağımlılığı olarak Mum Hacimleri göstergesinin mum ürününü içeren Mum Kalıpları göstergesinden bir örnektir:",
                    "updated": 1645973111262
                }
            ]
        },
        {
            "style": "Javascript",
            "text": "let candle = record.current // Calling \"Candles\"\nlet basicCandle = getElement ('basicCandles', candle) // Calling \"Basic Candles\"",
            "updated": 1621105552115
        },
        {
            "style": "Subtitle",
            "text": "getTimestampElement Function",
            "updated": 1621105629181,
            "translations": [
                {
                    "language": "RU",
                    "text": "Функция getTimestampElement",
                    "updated": 1639677507588
                },
                {
                    "language": "TR",
                    "text": "getTimestampElement İşlevi",
                    "updated": 1645973158887
                }
            ]
        },
        {
            "style": "Text",
            "text": "Indicators might have parameters that influences it's calculations. These parameters are defined at the Product Definition config, and their values are set at the Process Instance config. Parameters are extracted at the Procedure Initialization Code. In order to facilitate this extraction we will create an object here that will be accesed from the Procedure Initialization with all parameters and their defined values.",
            "updated": 1621105691314,
            "translations": [
                {
                    "language": "DE",
                    "text": "Indikatoren können Parameter haben, die ihre Berechnungen beeinflussen. Diese Parameter werden in der Process Instance config definiert, und ihre Werte werden in der Process Instance config festgelegt. Die Parameter werden im Initialization Code der Prozedur extrahiert. Um diese Extraktion zu erleichtern, erstellen wir hier ein Objekt, auf das von der Procedure Initialization aus mit allen Parametern und ihren definierten Werten zugegriffen werden kann.",
                    "updated": 1635356111873
                },
                {
                    "language": "RU",
                    "text": "Индикаторы могут иметь параметры, влияющие на их расчеты. Эти параметры определяются в конфигурации определения продукта Product Definition, а их значения устанавливаются в конфигурации экземпляра процесса Process Instance. Параметры извлекаются из кода инициализации процедуры Procedure Initialization. Чтобы облегчить это извлечение, мы создадим здесь объект, который будет приниматься из процедуры инициализации со всеми параметрами и их определенными значениями.",
                    "updated": 1639677736261
                },
                {
                    "language": "TR",
                    "text": "Göstergeler, hesaplamalarını etkileyen parametrelere sahip olabilir. Bu parametreler Ürün Tanımı ( Product Definition ) yapılandırmasında tanımlanır ve değerleri İşlem Eşgörünümü yapılandırmasında ayarlanır. Parametreler, Prosedür Başlatma ( Procedure Initialization ) Kodunda çıkarılır. Bu çıkarımı kolaylaştırmak için burada, tüm parametreler ve tanımlı değerleri ile Prosedür Başlatma'dan erişilecek bir nesne oluşturacağız.",
                    "updated": 1645973269612
                }
            ]
        },
        {
            "style": "Text",
            "text": ""
        },
        {
            "style": "Javascript",
            "text": "let currentAssetMetrics = getTimestampElement('assetMetrics', record.current)",
            "updated": 1621105716567
        },
        {
            "style": "Title",
            "text": "Variable Object",
            "updated": 1611431014179,
            "translations": [
                {
                    "language": "RU",
                    "text": "Переменный объект (Variable Object)",
                    "updated": 1639677770787
                },
                {
                    "language": "TR",
                    "text": "Değişken Nesne",
                    "updated": 1645973291606
                }
            ]
        },
        {
            "style": "Text",
            "text": "The output generated must be stored as new properties of the variable object, which is made available to record properties under the record definition node.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Die erzeugten Ausgaben müssen als neue properties des variable object gespeichert werden, das den record properties unter dem record definition node zur Verfügung gestellt wird.",
                    "updated": 1635356249718
                },
                {
                    "language": "RU",
                    "text": "Сгенерированный вывод должен быть сохранен как новые свойства объекта переменной, который становится доступным для записи свойств в узле определения записи Record Definition.",
                    "updated": 1639677824227
                },
                {
                    "language": "TR",
                    "text": "Üretilen çıktı, kayıt tanımlama düğümü altındaki özelliklerin kaydedilmesi için kullanıma sunulan değişken nesnenin yeni özellikleri olarak saklanmalıdır.",
                    "updated": 1645973313663
                }
            ]
        },
        {
            "style": "Text",
            "text": "In the case of the data building procedure loop, the variable object may also be used to store and—later—retrieve information between different loop cycles, or even between different executions of the indicator process. Such a feature is not available in the calculations procedure loop, as the object does not persist beyond each loop in that context.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Im Falle der data building procedure loop kann das variable object auch dazu verwendet werden, Informationen zwischen verschiedenen Schleifenzyklen oder sogar zwischen verschiedenen Ausführungen des indicator process zu speichern und später abzurufen. In der calculations procedure loop ist eine solche Funktion nicht verfügbar, da das object in diesem Kontext nicht über jede Schleife hinaus bestehen bleibt.",
                    "updated": 1635356359862
                },
                {
                    "language": "RU",
                    "text": "В случае цикла процедуры построения данных переменный объект также может использоваться для хранения и - позже - извлечения информации между различными тактами цикла или даже между различными выполнениями индикаторного процесса. Такая функция недоступна в цикле процедуры расчетов (Calculations Procedure), поскольку объект не сохраняется за пределами каждого цикла в этом контексте.",
                    "updated": 1639678261995
                },
                {
                    "language": "TR",
                    "text": "Veri oluşturma prosedürü döngüsü durumunda, değişken nesne, farklı döngü döngüleri arasında veya hatta gösterge sürecinin farklı yürütmeleri arasında bilgi depolamak ve daha sonra almak için de kullanılabilir. Nesne bu bağlamda her döngünün ötesinde kalıcı olmadığından, böyle bir özellik hesaplama prosedürü döngüsünde mevcut değildir.",
                    "updated": 1645973336887
                }
            ]
        },
        {
            "style": "Title",
            "text": "Multi-Time-Frame-Daily",
            "translations": [
                {
                    "language": "TR",
                    "text": "Çoklu-Zaman-Çerçeve-Günlük (Multi-Time-Frame-Daily)",
                    "updated": 1645973356268
                }
            ]
        },
        {
            "style": "Text",
            "text": "In time frames below one hour, the system allows to access data up to 48 hours in the past, relative to the current record. If more than 48-hours worth of data is required to produce the desired data building, then data must be stored into the variable object to be retrieved later on, as explained above.",
            "translations": [
                {
                    "language": "DE",
                    "text": "In Zeiträumen von weniger als einer Stunde erlaubt das System den Zugriff auf Daten, die bis zu 48 Stunden in der Vergangenheit liegen, bezogen auf den aktuellen Datensatz. Werden mehr als 48 Stunden an Daten benötigt, um das gewünschte data building zu erstellen, müssen die Daten in dem variable object gespeichert werden, um später abgerufen werden zu können (wie oben erklärt).",
                    "updated": 1635356432924
                },
                {
                    "language": "RU",
                    "text": "В периоды времени менее одного часа система позволяет получать доступ к данным за последние 48 часов относительно текущей записи. Если для создания желаемого построения данных требуется более 48 часов данных, то данные должны быть сохранены в переменном объекте для последующего извлечения, как описано выше.",
                    "updated": 1639678535937
                },
                {
                    "language": "TR",
                    "text": "Bir saatin altındaki zaman dilimlerinde sistem, mevcut kayda göre 48 saat öncesine kadar olan verilere erişime izin verir. İstenen veri oluşturmayı oluşturmak için 48 saatten fazla veri gerekiyorsa, yukarıda açıklandığı gibi veriler daha sonra alınacak değişken nesnede saklanmalıdır.",
                    "updated": 1645973388804
                }
            ]
        },
        {
            "style": "Important",
            "text": "Procedures may only access data up to 48 hours in the past counting from the datetime of the record being processed. For example, the calculation of a moving average spanning 100 periods requires temporarily storing data in an array, as the 45 minutes time frame needs 75-hours worth of data.",
            "updated": 1611431032118,
            "translations": [
                {
                    "language": "DE",
                    "text": "Verfahren können nur auf Daten zugreifen, die bis zu 48 Stunden in die Vergangenheit zurückreichen, gerechnet ab dem Datum des zu verarbeitenden Datensatzes. Die Berechnung eines gleitenden Durchschnitts (moving average), der sich über 100 Perioden erstreckt, erfordert beispielsweise die Zwischenspeicherung von Daten in einem Array, da für den Zeitrahmen von 45 Minuten Daten im Wert von 75 Stunden benötigt werden.",
                    "updated": 1635356514722
                },
                {
                    "language": "RU",
                    "text": "Процедуры могут обращаться к данным только за прошедшие 48 часов, считая от времени даты обрабатываемой записи. Например, расчет скользящего среднего, охватывающего 100 периодов, требует временного хранения данных в массиве, поскольку для временного интервала в 45 минут требуется 75 часовых данных.",
                    "updated": 1639721265072
                },
                {
                    "language": "TR",
                    "text": "Önemli: Prosedürler, işlenmekte olan kaydın tarihinden itibaren yalnızca 48 saat öncesine kadar olan verilere erişebilir. Örneğin, 45 dakikalık zaman çerçevesi 75 saatlik veriye ihtiyaç duyduğundan, 100 dönemi kapsayan hareketli bir ortalamanın hesaplanması, verilerin bir dizide geçici olarak depolanmasını gerektirir.",
                    "updated": 1645973399900
                }
            ]
        },
        {
            "style": "Text",
            "text": "The following is an example of a procedure loop code, in particular, the code that calculates the Popular SMAs product of the Simple Moving Average (SMA) indicator. Notice how the output generated by the calculateSMA function is stored into the variable object, and how an array stored in the variable object is used to overcome the 48-hours data-access limitation of Multi-Priod-Daily time frames.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Im Folgenden finden Sie ein Beispiel für einen procedure loop code, insbesondere den Code, der das Produkt Popular SMAs des Simple Moving Average (SMA) Indikators berechnet. Beachten Sie, wie die von der Funktion calculateSMA erzeugte Ausgabe im variable object gespeichert wird und wie ein im variable object gespeichertes Array verwendet wird, um die 48-Stunden-data-access limitation (Datenzugriffsbeschränkung) von Multi-Priod-Daily Zeitrahmen zu überwinden.",
                    "updated": 1635356663510
                },
                {
                    "language": "RU",
                    "text": "Ниже приведен пример кода цикла процедуры, в частности, кода, который вычисляет продут Popular SMA индикатора Simple Moving Average (SMA). Обратите внимание, как вывод, генерируемый функцией calculateSMA, сохраняется в объекте переменной, и как массив, хранящийся в объекте переменной, используется для преодоления 48-часового ограничения на доступ к данным для таймфреймов Multi-Priod-Daily.",
                    "updated": 1639721678638
                },
                {
                    "language": "TR",
                    "text": "Aşağıda, özellikle Basit Hareketli Ortalama ( Simple Moving Average ) (SMA) göstergesinin Popüler SMA'lar ürününü hesaplayan kod olmak üzere bir prosedür döngü kodu örneği verilmiştir. HesaplamaSMA işlevi tarafından üretilen çıktının değişken nesnede nasıl depolandığına ve Değişken nesnede depolanan bir dizinin Çoklu Priod-Günlük zaman çerçevelerinin 48 saatlik veri erişimi sınırlamasının üstesinden gelmek için nasıl kullanıldığına dikkat edin.",
                    "updated": 1645973442695
                }
            ]
        },
        {
            "style": "Javascript",
            "text": "/* Loop Code. */\n\nlet candle = record.current // Our main dependency is candles \nvariable.last200.push(candle.close) // Add the current close value to the last 200 array.\n\nif (variable.last200.length > 200) { // Store data in the variable object to overcome the limitations in Multi-Time-Frame-Daily.\n    variable.last200.splice(0, 1) // Remove the first element of the array to keep it at a maximun of 200 elements.\n}\n\nvariable.sma20 = calculateSMA(20)\nvariable.sma50 = calculateSMA(50)\nvariable.sma100 = calculateSMA(100)\nvariable.sma200 = calculateSMA(200)\n\nfunction calculateSMA(periods) {  // Having a function saves us from duplicating code.\n    /* We check we have enough values to make the calculation */\n    if (variable.last200.length < periods) { return 0 } // If we dont, we define the value is zero.\n\n    let sum = 0 // Initialize sum variable. \n    for (let i = variable.last200.length - periods; i < variable.last200.length; i++) { // Iterate through the last periods\n        sum = sum + variable.last200[i]\n    }\n    let sma = sum / periods\n    return sma\n}",
            "updated": 1611431047895
        },
        {
            "style": "Title",
            "text": "Irregular Periods",
            "updated": 1611431066723,
            "translations": [
                {
                    "language": "DE",
                    "text": "Irregular Periods (Irreguläre Perioden):",
                    "updated": 1635356682237
                },
                {
                    "language": "RU",
                    "text": "Нерегулярные периоды (Irregular Periods)",
                    "updated": 1639722557754
                },
                {
                    "language": "TR",
                    "text": "Düzensiz Dönemler",
                    "updated": 1645973469924
                }
            ]
        },
        {
            "style": "Text",
            "text": "Occasionally, a one-to-one mapping of the periods of the data dependency with the periods of the resulting product does not exist. For example, in the case of the bollingerChannels product, using the bollingerBands as the main dependency. In such a case, the algorithm may read the 1-hour bollingerBands as input but the resulting object may span several hours.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Hin und wieder gibt es keine Eins-zu-Eins-Zuordnung zwischen den Perioden der Datenabhängigkeit und den Perioden des resultierenden Produkts. Zum Beispiel im Fall des bollingerChannels product, das die bollingerBands als main dependency verwendet. In einem solchen Fall kann der Algorithmus die 1-hour bollingerBands als Eingabe lesen, aber das resultierende object kann sich über mehrere Stunden erstrecken.",
                    "updated": 1635356783859
                },
                {
                    "language": "RU",
                    "text": "Иногда не существует однозначного сопоставления периодов зависимости данных с периодами конечного продукта. Например, в случае продукта bollingerChannels, использующего в качестве основной зависимости bollingerBands. В этом случае алгоритм может считывать 1-часовые полосы Боллинджера в качестве входных данных, но результирующий объект может охватывать несколько часов.",
                    "updated": 1639722619765
                },
                {
                    "language": "TR",
                    "text": "Bazen, elde edilen ürünün dönemleri ile veri bağımlılığı dönemlerinin bire bir eşlemesi mevcut değildir. Örneğin, bollingerChannels ürünü söz konusu olduğunda, ana bağımlılık olarak bollingerBands öğesinin kullanılması. Böyle bir durumda, algoritma 1 saatlik bollingerBand'leri girdi olarak okuyabilir, ancak ortaya çıkan nesne birkaç saat sürebilir.",
                    "updated": 1645973479374
                }
            ]
        },
        {
            "style": "Text",
            "text": "By default, the system pushes a record into the data collection for every loop. To build products that span several periods of the main dependency, you must make the push from within your own code.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Standardmäßig schiebt das System bei jeder Schleife einen Datensatz in die Datensammlung. Um Produkte zu erstellen, die sich über mehrere Perioden der Hauptabhängigkeit erstrecken, müssen Sie den Push in Ihrem eigenen Code durchführen.",
                    "updated": 1635356902606
                },
                {
                    "language": "RU",
                    "text": "По умолчанию система переносит запись в коллекцию данных для каждого цикла. Для создания продуктов, которые охватывают несколько периодов основной зависимости, вы должны выполнять это действие из собственного кода.",
                    "updated": 1639723688268
                },
                {
                    "language": "TR",
                    "text": "Varsayılan olarak, sistem her döngü için veri toplamaya bir kayıt gönderir. Ana bağımlılığın birkaç periyodunu kapsayan ürünler oluşturmak için, kendi kodunuzdan baskı yapmanız gerekir.",
                    "updated": 1645973505270
                }
            ]
        },
        {
            "style": "Text",
            "text": "When the system detects a push in the procedure loop code, it cancels the automatic push on each loop.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Wenn das System einen Push im Code der procedure loop feststellt, bricht es den automatischen Push in jeder Schleife ab.",
                    "updated": 1635356945154
                },
                {
                    "language": "RU",
                    "text": "Когда система обнаруживает перенос в коде процедурного цикла, она отменяет автоматическое перенос в каждом цикле.",
                    "updated": 1639723664544
                },
                {
                    "language": "TR",
                    "text": "Sistem, prosedür döngü kodunda bir push bildirimi algıladığında, her döngüde otomatik push işlemini iptal eder.",
                    "updated": 1645973514947
                }
            ]
        },
        {
            "style": "Text",
            "text": "The following example taken from the data building procedure loop of the Bollinger Channels Object indicator features several instances of arbitrary use of pushes.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Das folgende Beispiel aus der Schleife der data building procedure loop des Bollinger Channels Object zeigt mehrere Beispiele für die willkürliche Verwendung von Pushs.",
                    "updated": 1635357060928
                },
                {
                    "language": "RU",
                    "text": "Следующий пример, взятый из цикла процедуры построения данных индикатора Bollinger Channels Object, содержит несколько примеров произвольного использования переносов.",
                    "updated": 1639723579255
                },
                {
                    "language": "TR",
                    "text": "Bollinger Kanalları Nesne göstergesinin veri oluşturma prosedürü döngüsünden alınan aşağıdaki örnekte, çeşitli itme kullanımı örnekleri bulunmaktadır.",
                    "updated": 1645973524422
                }
            ]
        },
        {
            "style": "Javascript",
            "text": "if (record.next !== undefined) {\n\n    if (\n        record.current.direction === record.next.direction) {\n\n        if (variable.channel === undefined) {\n\n            variable.channel = {\n                begin: undefined,\n                end: undefined,\n                direction: undefined,\n                period: 0,\n                firstMovingAverage: 0,\n                lastMovingAverage: 0,\n                firstDeviation: 0,\n                lastDeviation: 0\n            }\n\n            variable.channel.direction = record.current.direction\n            variable.channel.period = 2\n\n            variable.channel.begin = record.current.begin\n            variable.channel.end = record.next.end\n\n            variable.channel.firstMovingAverage = record.current.movingAverage\n            variable.channel.lastMovingAverage = record.next.movingAverage\n\n            variable.channel.firstDeviation = record.current.deviation\n            variable.channel.lastDeviation = record.next.deviation\n\n        } else {\n\n            variable.channel.period++\n            variable.channel.end = record.next.end\n            variable.channel.lastMovingAverage = record.next.movingAverage\n            variable.channel.lastDeviation = record.next.deviation\n\n        }\n    } else {\n\n        if (variable.channel !== undefined) {\n            results.push(variable.channel)\n            variable.channel = undefined\n        } else {\n            /* The variable.channel has only one period */\n\n            variable.channel = {}\n\n            variable.channel.direction = record.current.direction\n            variable.channel.period = 1\n\n            variable.channel.begin = record.current.begin\n            variable.channel.end = record.current.end\n\n            variable.channel.firstMovingAverage = record.current.movingAverage\n            variable.channel.lastMovingAverage = record.current.movingAverage\n\n            variable.channel.firstDeviation = record.current.deviation\n            variable.channel.lastDeviation = record.current.deviation\n\n            results.push(variable.channel)\n            variable.channel = undefined\n        }\n    }\n} else {\n    if (variable.channel !== undefined) {\n        variable.channel.period++\n        variable.channel.end = record.current.end\n        variable.channel.lastMovingAverage = record.current.movingAverage\n        variable.channel.lastDeviation = record.current.deviation\n        results.push(variable.channel)\n        variable.channel = undefined\n    } else {\n        /* The variable.channel has only one period */\n\n        variable.channel = {}\n\n        variable.channel.direction = record.current.direction\n        variable.channel.period = 1\n\n        variable.channel.begin = record.current.begin\n        variable.channel.end = record.current.end\n\n        variable.channel.firstMovingAverage = record.current.movingAverage\n        variable.channel.lastMovingAverage = record.current.movingAverage\n\n        variable.channel.firstDeviation = record.current.deviation\n        variable.channel.lastDeviation = record.current.deviation\n\n        results.push(variable.channel)\n        variable.channel = undefined\n    }\n}",
            "updated": 1611431088524
        },
        {
            "style": "Title",
            "text": "Managing Undefined Objects",
            "updated": 1611431116629,
            "translations": [
                {
                    "language": "DE",
                    "text": "Undefined Objects verwalten:",
                    "updated": 1635357087320
                },
                {
                    "language": "RU",
                    "text": "Управление неопределенными объектами (Managing Undefined Objects)",
                    "updated": 1639723717529
                },
                {
                    "language": "TR",
                    "text": "Tanımsız Nesneleri Yönetme",
                    "updated": 1645973577744
                }
            ]
        },
        {
            "style": "Text",
            "text": "In many instances, objects may be undefined. For example, the first 199 candles in the data collection corresponding to a 200-period moving average may be undefined, as the data building procedure may only build the object once the 200th candle is evaluated.",
            "translations": [
                {
                    "language": "DE",
                    "text": "In vielen Fällen können die Objekte undefiniert sein. Beispielsweise können die ersten 199 candles in der Datensammlung, die einem gleitenden 200-Perioden-Durchschnitt entsprechen, undefiniert sein, da die Datenerstellungsprozedur das Objekt möglicherweise erst nach der Auswertung der 200sten candle erstellt.",
                    "updated": 1635357128634
                },
                {
                    "language": "RU",
                    "text": "Во многих случаях объекты могут быть неопределенными. Например, первые 199 свечей в коллекции данных, соответствующих 200-периодной скользящей средней, могут быть неопределенными, поскольку процедура построения данных может построить объект только после оценки 200-й свечи.",
                    "updated": 1639723755351
                },
                {
                    "language": "TR",
                    "text": "Bir çok durumda, nesneler tanımsız olabilir. Örneğin, 200 dönemlik hareketli ortalamaya karşılık gelen veri toplamadaki ilk 199 mum tanımsız olabilir, çünkü veri oluşturma prosedürü nesneyi yalnızca 200. mum değerlendirildikten sonra oluşturabilir.",
                    "updated": 1645973591357
                }
            ]
        },
        {
            "style": "Text",
            "text": "Storing undefined property values is highly undesirable, as that would likely produce errors downstream when others attempt to consume the products produced by the indicator. How to handle such circumstances is up to the developer.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Die Speicherung von undifined property values ist höchst unerwünscht, da dies wahrscheinlich zu Fehlern führen würde, wenn andere versuchen, die von dem indicator erzeugten Produkte zu konsumieren. Wie man mit solchen Umständen umgeht, bleibt dem Entwickler überlassen.",
                    "updated": 1635357275201
                },
                {
                    "language": "RU",
                    "text": "Хранение неопределенных значений свойств крайне нежелательно, так как это, скорее всего, приведет к ошибкам, когда другие попытаются использовать продукты, произведенные индикатором. Как поступать в таких случаях, зависит от разработчика.",
                    "updated": 1647784681799
                },
                {
                    "language": "TR",
                    "text": "Başkaları gösterge tarafından üretilen ürünleri tüketmeye çalıştığında aşağı yönde hatalara yol açacağından, tanımlanmamış mülk değerlerinin saklanması oldukça istenmeyen bir durumdur. Bu tür durumlarla nasıl başa çıkılacağı geliştiriciye bağlıdır.",
                    "updated": 1645973604241
                }
            ],
            "updated": 1647236335266
        },
        {
            "style": "Text",
            "text": "The Bollinger Channels Object example above features deliberate handling of undefined objects.",
            "translations": [
                {
                    "language": "DE",
                    "text": "Das obige Beispiel des Bollinger Channels Object zeichnet sich durch den bewussten Umgang mit undefinierten Objekten aus.",
                    "updated": 1635357307246
                },
                {
                    "language": "RU",
                    "text": "Приведенный выше пример на Bollinger Channels Object отличается продуманной работой с неопределенными объектами.",
                    "updated": 1639723883623
                },
                {
                    "language": "TR",
                    "text": "Yukarıdaki Bollinger Kanalları Nesnesi örneği, tanımsız nesnelerin kasıtlı olarak ele alınmasını içerir.",
                    "updated": 1645973612909
                }
            ]
        },
        {
            "style": "Text",
            "text": "In the case of a 200-period moving average discussed above, the developer may want to produce an arbitrary estimation of the moving average for the first 199 candles, or simply set the value to zero for the first 199 candles. The later was the choice for the popularSMAs product as may be observed in the code of the initialization procedure:",
            "translations": [
                {
                    "language": "DE",
                    "text": "Im Falle des oben beschriebenen  200-period moving average kann der Entwickler eine beliebige Schätzung des gleitenden Durchschnitts für die ersten 199 Kerzen vornehmen oder den Wert für die ersten 199 Kerzen einfach auf Null setzen. Letzteres wurde für das Produkt popularSMAs gewählt, wie im Code der initialization procedure zu sehen ist:",
                    "updated": 1635357513374
                },
                {
                    "language": "RU",
                    "text": "В случае 200-периодного скользящего среднего, о котором говорилось выше, разработчик может захотеть произвести произвольную оценку скользящего среднего для первых 199 свечей или просто установить значение нуля для первых 199 свечей. Последнее было выбрано для продукта popularSMA, что можно заметить в коде процедуры инициализации:",
                    "updated": 1639723960686
                },
                {
                    "language": "TR",
                    "text": "Yukarıda tartışılan 200 dönemlik hareketli ortalama durumunda, geliştirici ilk 199 mum için hareketli ortalamanın keyfi bir tahminini üretmek veya ilk 199 mum için değeri sıfıra ayarlamak isteyebilir. Başlatma prosedürünün kodunda görülebileceği gibi, popülerSMA ürününün seçimi daha sonraydı:",
                    "updated": 1645973620228
                }
            ]
        },
        {
            "style": "Javascript",
            "text": "/* Initialization Code*/\n\nvariable.previousEMA20 = 0\nvariable.previousEMA50 = 0\nvariable.previousEMA100 = 0\nvariable.previousEMA200 = 0",
            "updated": 1611431131070,
            "translations": [
                {
                    "language": "RU",
                    "text": "/* Initialization Code */\n\nvariable.previousEMA20 = 0\nvariable.previousEMA50 = 0\nvariable.previousEMA100 = 0\nvariable.previousEMA200 = 0",
                    "updated": 1639723968537
                }
            ]
        },
        {
            "style": "Text",
            "text": ""
        }
    ]
}